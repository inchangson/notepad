# Coroutine

> 한 스레드 내에서 멀티 태스킹을 가능하게 하는 기능

- 왜 굳이 multi-threading과 차이를 둘까?
- context-switching에 대한 처리를 안 하나?

## 장점?
- CPU 작업이 아닌 작업을(IO, ...) 병렬적으로 수행할 수 있다.
- 병렬(동시성 프로그래밍/ 비동기적 실행)성을 코루틴이 시작된 스레드를 중단하지 않으면서 사용할 수 있다. 
- 근데 이건 멀티 스레딩에서도 가능하지 않나?
  - 다수 스레드 관리를 직접하지 않아도 된다.
- 사용자가 원하는 작업의 흐름대로 프로그램을 구동할 수 있다.
  - 기존의 복잡한 Async task 관리를 직접 해주지 않아도 된다.
- 여건 상 멀티 스레드/ 프로세스를 돌리기 힘든 os/ hw에서도 활용 가능하다.

## 스레드와의 심화 비교
- 스레드에서 코루틴 1, 2, 3을 실행했다고 할 때
- 1 -> 2로 넘어가도 스레드는 기존 것을 유지
- 2 작업 중 1로 돌아가는 상황이면 저장해둔 1의 상태를 불러와 다시 스레드에서 코루틴 1을 실행
- 스레드를 단일로 사용함으로써
- 스레드 관련 이벤트 또는 결과 처리를 위한 콜백 작성이 필요없고 순차적으로 코드를 작성하면 되기 때문이다.

## 단점?
- ..

## 예시(잘 활용할 수 있는)
- ..

## 제공하는 문법(coroutine builder)
- 

### async/ await

### load

### custom coroutine builder

## coroutine scope
- 모든 코루틴은 스코프 내에서 실행되어야 하는데 이를 통해서 액티비티 또는 프래그먼트의 생명주기에 따라 소멸될 때 관련 코루틴을 한번에 취소할 수 있는데 이는 곧 메모리 누수를 방지한다.
- 스코프는 커스텀 또는 이미 내장된 범위를 사용할 수 있다.
- Coroutine scope는 사실 coroutine context 타입 필드를 launch 등의 확장함수 내부에서 사용하기 위한 매개체 역할만 담당한다.
- coroutine context는 실제로 코루틴이 실행중인 여러 작업과 디스페처를 저장하는 일종의 맵이다. 이를 통해 코틀린 런타임은 다음에 실행할 작업을 고르고 어떤 스레드에 배정할 지 결정한다.
- 모든 코루틴은 항상 자신이 속한 스코프를 참조해야 한다.

### global scope
- 앱의 생명주기와 함께 동작하기 때문에 생명주기 관리가 필요없음
- 시작 ~ 종료까지 긴기간 실행되는 코루틴의 경우에 적합
~~~
GlobalScope.launch{
    //DO IT
}
~~~
### coroutine scope
- 버튼을 눌러 다운로드 하거나 서버에서 이미지를 열 때 등, 필요할 때만 열고 완료되면 닫아주는 코루틴 스코프를 사용할 수 있습니다.
~~~
binding.downloadButton.setOnClickListener{
    CoroutineScope(Dispatchers.IO).launch{
        // DO IT
    }
}
~~~

## Coroutine Dispatcher
### Default
- 안드로이드 기본 스레드풀 사용, CPU 사용이 많은 작업에 최적화(데이터 정렬, 복잡한 연산)
### IO
- 이미지 다운로드, 파일 입출력(네트워크, 디스크, DB) 작업에 최적화

### Main
- 안드로이드 기본 스레드에서 코루틴 실행
- UI와 상호작용에 최적화

### Unconfined
- 호출된 컨텍스트를 기본으로 사용하는데 중단 후 다시 실행될 때 컨텍스트가 바뀌면 바뀐 컨텍스트를 따라서 실행

### Customized
- 용도에 맞게 어떤 스레드에 할당하고 코루틴 실행 도중 일지 정지/ 실행 재개를 설정하여 커스텀 디스패처를 생성할 수 있다.

